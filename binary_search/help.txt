В решении использовал алгоритм сжатия Simple9, реализовал потоковую обработку дерева запросов. 
Входящий запрос парсится методом рекурсивного спуска. Чтобы запустить парсинг, нужно инициализировать объект класса parser строкой-запросом,
а затем вызвать метод E(). На выходе получится корень дерева запроса. Поиск происходит в процедуре flow_search, которая принимает на вход
корень дерева запроса.
Скрипт index.sh в качестве параметров может принимать директории или пути до файлов в формате path/to/smth.gz . В этом скрипте происходит 
построение индекса и его сжатие. Если на вход подается директория, то порядок открытия в ней файлов зависит от результата работы метода 
os.listdir(по наблюдениям, на windows метод выдает файлы в лексикографическом порядке, на linux же свой, никому не известный порядок)
[если нужно поменять на лексикографический порядок, то в файле index.py необходимо раскомментировать строку 58]; если же на вход подаются 
файлы, то открываться они будут в том порядке, в каком были поданы на вход. При этом проверка на дубликаты не производится, то есть, если 
будут поданы файлы и директория, содержащая эти файлы, то результат поиска будет содержать дубликаты, которые находятся в общих файлах. 
Скрипт search.sh запускает разжатие индекса и начало поиска. Ожидается, что запросы будут подаваться на stdin. Предполагается, что запрос 
валидный : запрос, содержащий только пробелы или знаки табуляции (кроме '\n'), а так же любые знаки кроме \w+ , !, |, &, () считается 
инвалидным. Чтение запросов прекращается, когда в stdin встречается EOF.